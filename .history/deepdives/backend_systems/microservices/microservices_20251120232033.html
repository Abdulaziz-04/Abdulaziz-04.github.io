<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      Backend Microservices Suite: HTTP Utilities, Files, Time, and URLs
    </title>
    <link rel="stylesheet" href="../../../assets/css/styles.css" />
  </head>

  <body class="project-detail-page">
    <header class="detail-hero">
      <a class="category-back" href="../../../projects/backend_systems.html">
        &larr; Back to Projects
      </a>

      <p
        class="category-pill"
        onclick="window.location.href='../../../projects/backend_systems.html'"
      >
        Backend &amp; Distributed Logic
      </p>
      <br />

      <h1>Backend Microservices Suite</h1>

      <p class="detail-summary">
        <b>
          A small but fully working suite of Node.js microservices built for
          FreeCodeCamp’s Backend Development and APIs certification. Each
          service is independently deployable, exposes a clean JSON API, and is
          wired into a simple dashboard for local testing.
        </b>
      </p>

      <p class="detail-summary">
        I completed all backend projects and submitted these four services
        (request header parser, file metadata service, timestamp API, and URL
        shortener) as the final assignments, earning the
        <b>Backend Development and APIs certification</b>.
      </p>

      <ul class="detail-meta">
        <li>
          <strong>Tech Stack:</strong>
          Node.js, Express, MongoDB (NoSQL), middleware-based routing, CORS
        </li>
      </ul>
    </header>

    <main class="section detail-content">
      <!-- HERO IMAGE -->
      <section class="detail-section detail-hero-gif">
        <figure class="gallery-item gallery-item--wide">
          <img
            src="./images/intro.png"
            alt="Dashboard showing the four backend microservices and their endpoints"
            style="display: block; margin: 0 auto; max-width: 95%; height: auto"
          />
          <figcaption style="text-align: center">
            Local microservices dashboard. Each card launches the original UI
            and lets me test the underlying REST endpoint from a single place.
          </figcaption>
        </figure>
      </section>

      <!-- QUICK INSIGHTS -->
      <section class="detail-section">
        <h2>Quick insights</h2>
        <ul class="psr-list">
          <li>
            <strong>Goal:</strong>
            Build a set of focused microservices that demonstrate HTTP parsing,
            file handling, time conversion, and persistent URL shortening while
            following RESTful design and good error handling practices.
          </li>
          <br />
          <li>
            <strong>Scope:</strong>
            Four services running on separate ports behind a simple dashboard:
            Browser-IP “whoami” service, timestamp converter, file metadata
            analyzer, and a MongoDB-backed URL shortener.
          </li>
          <br />
          <li>
            <strong>Outcome:</strong>
            Delivered a clean, testable backend playground that can be
            containerized and deployed as independent services or as part of a
            larger API-gateway architecture.
          </li>
        </ul>
      </section>

      <!-- SERVICE OVERVIEW -->
      <section class="detail-section">
        <h2>Service overview</h2>
        <p>
          All four microservices are simple by design, but together they cover a
          lot of backend fundamentals: parsing HTTP headers, validating user
          input, translating between representations, handling file uploads, and
          persisting entities with a database.
        </p>

        <ul>
          <li>
            <b>Browser-IP microservice (whoami):</b>
            Returns a JSON snapshot of the client’s IP address, preferred
            language, and user-agent. Useful for debugging clients or building
            personalization layers.
          </li>
          <br />
          <li>
            <b>Timestamp microservice:</b>
            Accepts date strings or Unix timestamps, normalizes them, and
            returns both Unix and UTC representations, including for “now” when
            no parameter is given.
          </li>
          <br />
          <li>
            <b>File metadata microservice:</b>
            Receives uploads via multipart/form-data, inspects the file, and
            returns its name, MIME type, and size. Runs entirely in memory, no
            files are persisted to disk.
          </li>
          <br />
          <li>
            <b>URL shortener:</b>
            Validates and stores long URLs in MongoDB, generates a compact
            token, and redirects short URLs back to the original destination.
          </li>
        </ul>
      </section>

      <!-- RESPONSE EXAMPLES GALLERY -->
      <section class="detail-section detail-gallery">
        <h2>Sample responses</h2>
        <div class="gallery-row gallery-row--two">
          <figure class="gallery-item">
            <a href="./images/whoami.png" target="_blank">
              <img
                src="./images/whoami.png"
                alt="JSON response from whoami service showing ipaddress, language, and software"
              />
            </a>
            <figcaption>
              Browser-IP service returning IP, language, and user-agent string.
            </figcaption>
          </figure>

          <figure class="gallery-item">
            <a href="./images/timestamp.png" target="_blank">
              <img
                src="./images/timestamp.png"
                alt="Timestamp service converting a date string to Unix and UTC"
              />
            </a>
            <figcaption>
              Timestamp service converting <code>2015-12-25</code> to Unix and
              UTC formats.
            </figcaption>
          </figure>
        </div>

        <div class="gallery-row gallery-row--two">
          <figure class="gallery-item">
            <a href="./images/file_analyze.png" target="_blank">
              <img
                src="./images/file_analyze.png"
                alt="File metadata service returning name, type, and size of an uploaded PDF"
              />
            </a>
            <figcaption>
              File metadata service summarizing an uploaded PDF resume.
            </figcaption>
          </figure>

          <figure class="gallery-item">
            <a href="./images/url_shortner.png" target="_blank">
              <img
                src="./images/url_shortner.png"
                alt="URL shortener service returning original_url and short_url token"
              />
            </a>
            <figcaption>
              URL shortener service mapping a long FreeCodeCamp URL to a short
              token.
            </figcaption>
          </figure>
        </div>
      </section>

      <!-- ARCHITECTURE & DESIGN -->
      <section class="detail-section">
        <h2>Architecture and design choices</h2>
        <p>
          I intentionally structured these as independent Express apps to mimic
          a microservices setup instead of one monolith with many routes. Each
          service has its own port, middleware stack, and health checks, which
          makes it straightforward to containerize and scale them separately.
        </p>

        <ul>
          <li>
            <b>Express-first design:</b>
            Each service uses Express with a thin index file that wires up
            middleware, route handlers, and error handling. I use environment
            variables for ports and MongoDB URIs so the suite can run locally or
            on a cloud host without code changes.
          </li>
          <br />
          <li>
            <b>Shared patterns:</b>
            Even though the services are separate, they share patterns such as
            centralized validation, consistent JSON error structures, and
            clearly documented endpoints that mirror the FreeCodeCamp spec.
          </li>
        </ul>
      </section>

      <!-- EDGE CASES & ROBUSTNESS -->
      <section class="detail-section">
        <h2>Edge cases and robustness</h2>
        <p>
          To go beyond the bare minimum for the certification, I spent time
          thinking through failure modes and how APIs should behave when users
          supply odd inputs.
        </p>

        <ul>
          <li>
            <b>Timestamp parsing:</b>
            When the date parameter is missing, the service returns the current
            time. If the input is ambiguous, it tries Unix and ISO-8601 parsing,
            then returns a helpful JSON error instead of a 500. This mirrors how
            production APIs often have to be forgiving but explicit.
          </li>
          <br />
          <li>
            <b>File uploads:</b>
            The metadata service checks for missing files, unsupported content
            types, and empty payloads, and responds with a clear validation
            message. Uploads are limited in size and never written to disk,
            making it safe to run in memory-constrained environments.
          </li>
          <br />
          <li>
            <b>URL validation:</b>
            The shortener normalizes URLs, rejects malformed domains, and
            protects against non-http/https schemes. Duplicate URLs reuse the
            same mapping instead of creating multiple documents, which keeps the
            database small and predictable.
          </li>
          <br />
          <li>
            <b>Whoami service:</b>
            If the IP header is missing or proxied, the service gracefully falls
            back to the connection’s remote address. It returns language and
            user-agent exactly as seen, which helps debug issues without
            mutating data.
          </li>
        </ul>
      </section>

      <!-- SCALING & FUTURE ENHANCEMENTS -->
      <section class="detail-section">
        <h2>Scaling and Future Enhancements</h2>
        <p>
          These projects started as learning exercises, but the design makes it
          easy to evolve them into production-ready components.
        </p>

        <ul>
          <li>
            <b>Containerization and orchestration:</b>
            Each service can be packaged as a small Docker image and deployed
            behind an API gateway such as Nginx or an ingress controller in
            Kubernetes. Horizontal scaling then becomes a matter of increasing
            replica counts per service.
          </li>
          <br />
          <li>
            <b>Persistent analytics:</b>
            The whoami and timestamp services could log anonymized usage stats
            to a time-series store (for example, Prometheus or a simple Postgres
            table) to visualize traffic patterns and client platforms.
          </li>
          <br />
          <li>
            <b>Hardened URL shortener:</b>
            Adding rate limiting, per-user quotas, and link expiration would
            turn the shortener into a more realistic service. A background job
            could clean up expired links while preserving click statistics.
          </li>
          <br />
          <li>
            <b>File gateway:</b>
            The metadata service could be extended to temporarily store files in
            S3 or another object store and act as a front door for larger upload
            workflows, while still returning immediate metadata to the client.
          </li>
        </ul>
      </section>

      <!-- IMPACT & LEARNINGS -->
      <section class="detail-section detail-impact">
        <h2>Impact and learnings</h2>
        <ul>
          <li>
            <b>Microservice mindset:</b>
            Even though these services are small, building and running four
            separate backends taught me how to think about boundaries,
            observability, and independent deployments.
          </li>
          <br />
          <li>
            <b>API ergonomics:</b>
            Designing simple, predictable JSON responses and handling weird user
            input gracefully is something I now carry into my larger backend
            work.
          </li>
          <br />
          <li>
            <b>Production readiness:</b>
            Experimenting with validation, error messages, and database
            interactions here gave me a small sandbox to practice habits that
            scale to more complex microservice architectures.
          </li>
        </ul>
      </section>
    </main>
  </body>
</html>
